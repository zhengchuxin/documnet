{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"Y0371","rootPoint":{"objectClass":"CGPoint","x":415,"y":1319.125},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"NCWH6","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"61GPH","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"683T1","lineColorHex":"#37C45A","text":"是只读特性 只会生成getter方法 ，不会生成setter方法。不希望属性在类外改变。"},"objectClass":"NSArray"},"text":"readwrite"},"1":{"objectClass":"MindNode","ID":"EA4EE","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"9DL01","lineColorHex":"#37C45A","text":"是只读特性 只会生成getter方法 ，不会生成setter方法。不希望属性在类外改变。"},"objectClass":"NSArray"},"text":"readonly"},"objectClass":"NSArray"},"text":"读写权限"},"1":{"objectClass":"MindNode","ID":"B86E2","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"V7865","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"3Q1R6","lineColorHex":"#26BBFF","text":"非原子操作。决定编译器生成的setter和getter方法是否是原子操作"},"objectClass":"NSArray"},"text":"nonatomic"},"1":{"objectClass":"MindNode","ID":"H6V4P","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"Q8U36","lineColorHex":"#26BBFF","text":"表示多线程安全，一般使用nonatomic，效率高。（保证对成员属性的赋值和获取是线程安全的）但是如果进行数组进行操作，比如给数据加对象或移除对象，是不在atomic的保证范围。"},"1":{"objectClass":"MindNode","ID":"23XDV","lineColorHex":"#26BBFF","text":"使⽤了同步锁，会在创建时生成⼀些额外的代码⽤于帮助编写多线程程序，这会带来性能问题。"},"2":{"objectClass":"MindNode","ID":"3J765","lineColorHex":"#26BBFF","text":"⼀般情况下并不要求属性必须是“原⼦的”，因为这并不能保证“线程安全”(thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。\n例如，⼀个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。"},"objectClass":"NSArray"},"text":"atomic（默认修饰符）"},"objectClass":"NSArray"},"text":"原子类"},"2":{"objectClass":"MindNode","ID":"10H4I","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"36M65","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"225EI","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"6BC2D","lineColorHex":"#BF58F5","text":"用途（ NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；）为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。"},"1":{"objectClass":"MindNode","ID":"K6XUF","lineColorHex":"#BF58F5","text":"用途（block 也经常使用 copy 关键字）block 使用。\n copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,由于手动管理引用计数，需要copy到堆区来防止野指针错误，使用 copy 可以把它放到堆区.\n在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。\n"},"2":{"objectClass":"MindNode","ID":"WCDBV","lineColorHex":"#BF58F5","text":"因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本"},"objectClass":"NSArray"},"text":"表示拷贝特性。setter方法将传入对象复制一份，需要完全一份新的变量时。修饰不可变对象"},"objectClass":"NSArray"},"text":"copy"},"1":{"objectClass":"MindNode","ID":"X1SG8","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"52N3U","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"2NU8K","lineColorHex":"#BF58F5","text":"setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1。release引起引用计数减1。当引用计数为0时，dealloc函数被调用，内存被回收。"},"objectClass":"NSArray"},"text":"强引用类型，ARC下相当于strong，但block不能用retain修饰，因为等同于assign不安全。"},"objectClass":"NSArray"},"text":"retain"},"2":{"objectClass":"MindNode","ID":"WG442","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"379QH","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"8L6TI","lineColorHex":"#BF58F5","text":"指向并拥有该对象。其修饰的对象引用计数会加1。该对象只要引用计数不为0则不会被销毁。当然强制将其置为nil也可以销毁它。"},"objectClass":"NSArray"},"text":"修饰可变对象。强引用类型，修饰block时相当于copy"},"objectClass":"NSArray"},"text":"strong"},"3":{"objectClass":"MindNode","ID":"8U5G7","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"1H535","lineColorHex":"#BF58F5","text":"表示指向但不拥有该对象。\n对象引用计数为0时，属性值也会自动置nil。 weak 必须用于 OC 对象。\n"},"1":{"objectClass":"MindNode","ID":"846F0","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"P33J2","lineColorHex":"#BF58F5","text":"在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。"},"1":{"objectClass":"MindNode","ID":"Q9460","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"J52ET","lineColorHex":"#BF58F5","text":"IBOutlet连出来的视图属性为什么可以被设置成weak?\n    因为父控件的subViews数组已经对它有一个强引用。"},"objectClass":"NSArray"},"text":"自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。"},"objectClass":"NSArray"},"text":"Runtime 维护了一个weak_table_t 弱引用表 ,用于存储指向某一个对象的所有weak指针。\nweak表其实是一个哈希表， key是所指对象的地址，value是weak指针的地址的数组。\n在对象回收的时候，根据对象的地址将所有weak指针地址的数组，遍历数组把其中的数据置为nil"},"objectClass":"NSArray"},"text":"weak(IOS5.0以后)"},"4":{"objectClass":"MindNode","ID":"7F423","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"5H6AG","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"U8R30","lineColorHex":"#BF58F5","text":"是赋值特性。setter方法将传入参数赋值给实例变量;仅设置变量时,assign用于基本数据类型"},"objectClass":"NSArray"},"text":"1: assign 的对象被释放之后，对象指针还是会指向原来的地址，会产生悬垂指针 ,导致程序内存泄露和程序崩溃。\n2: 用于基本数据类型和结构体。如果修饰对象的话，当销毁时，属性值不会自动置nil，可能造成野指针。可以用非 OC 对象"},"1":{"objectClass":"MindNode","ID":"4EC1M","lineColorHex":"#BF58F5","text":"野指针：不是NULL指针，是指向\"垃圾\"内存（不可用内存）的指针"},"2":{"objectClass":"MindNode","ID":"1Y460","lineColorHex":"#BF58F5","text":"基本数据类型是分配在栈上，栈上空间的分配和回收都是系统来处理的，因此开发者无需关注，也就不会产生野指针的问题"},"objectClass":"NSArray"},"text":"assign"},"5":{"objectClass":"MindNode","ID":"4HIPM","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"6L28L","lineColorHex":"#BF58F5","text":"指针指向的对象被释放时，unsafe_unretain指针不会被置为nil,而变成了野指针，再次使用就会造成crash."},"objectClass":"NSArray"},"text":"Unsafe_Unretain(IOS5.0之前)"},"objectClass":"NSArray"},"text":"内存管理引用计数"},"objectClass":"NSArray"},"text":"属性关键字"}}