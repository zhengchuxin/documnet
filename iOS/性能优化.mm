{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"5P780","rootPoint":{"objectClass":"CGPoint","x":415,"y":2563.5},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"SQUV8","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"28WRA","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"R74IR","lineColorHex":"#DC306C","text":"1.最常用的就是cell的重用， 注册重用标识符\n如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell\n如果有很多数据的时候，就会堆积很多cell。\n如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell"},"1":{"objectClass":"MindNode","ID":"8S828","lineColorHex":"#DC306C","text":"2.避免cell的重新布局\ncell的布局填充等操作 比较耗时，一般创建时就布局好\n如可以将cell单独放到一个自定义类，初始化时就布局好"},"2":{"objectClass":"MindNode","ID":"T565B","lineColorHex":"#DC306C","text":"3.提前计算并缓存cell的属性及内容\n当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度\n而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创\t建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell"},"3":{"objectClass":"MindNode","ID":"G6U37","lineColorHex":"#DC306C","text":"4.减少cell中控件的数量\n尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，\n不适用的可以先隐藏\n"},"4":{"objectClass":"MindNode","ID":"GWT66","lineColorHex":"#DC306C","text":"5.不要使用ClearColor，无背景色，透明度也不要设置为0\n渲染耗时比较长"},"5":{"objectClass":"MindNode","ID":"13263","lineColorHex":"#DC306C","text":"6.使用局部更新\n如果只是更新某组的话，使用reloadSection进行局部更\n"},"6":{"objectClass":"MindNode","ID":"TO7EN","lineColorHex":"#DC306C","text":"7.加载网络数据，下载图片，使用异步加载，并缓存"},"7":{"objectClass":"MindNode","ID":"W3W0Q","lineColorHex":"#DC306C","text":"8.少使用addView 给cell动态添加view"},"8":{"objectClass":"MindNode","ID":"3J5J5","lineColorHex":"#DC306C","text":"9.按需加载cell，cell滚动很快时，只加载范围内的cell"},"9":{"objectClass":"MindNode","ID":"Y4DLW","lineColorHex":"#DC306C","text":"10.不要实现无用的代理方法，tableView只遵守两个协议"},"10":{"objectClass":"MindNode","ID":"092Y2","lineColorHex":"#DC306C","text":"11.缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可"},"11":{"objectClass":"MindNode","ID":"1108V","lineColorHex":"#DC306C","text":"12.不要做多余的绘制工作。在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。"},"12":{"objectClass":"MindNode","ID":"XHXSB","lineColorHex":"#DC306C","text":"13.预渲染图像。当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕"},"objectClass":"NSArray"},"text":"tableView卡顿的原因"},"1":{"objectClass":"MindNode","ID":"03JAD","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"LBPU5","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"88S66","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"G30DR","lineColorHex":"#DC306C","text":"1: 尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView"},"1":{"objectClass":"MindNode","ID":"D51B1","lineColorHex":"#DC306C","text":"2: 不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改"},"2":{"objectClass":"MindNode","ID":"X27EH","lineColorHex":"#DC306C","text":"3: 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性"},"3":{"objectClass":"MindNode","ID":"G286T","lineColorHex":"#DC306C","text":"4: Autolayout 会比直接设置 frame 消耗更多的 CPU 资源"},"4":{"objectClass":"MindNode","ID":"VC2JX","lineColorHex":"#DC306C","text":"5: 图片的 size 最好刚好跟 UIImageView 的 size 保持一致"},"5":{"objectClass":"MindNode","ID":"7T40B","lineColorHex":"#DC306C","text":"6: 尽量把耗时的操作放到子线程\n图片处理（解码、绘制）"},"objectClass":"NSArray"},"text":"CPU：对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制"},"1":{"objectClass":"MindNode","ID":"7KN87","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"Y1G21","lineColorHex":"#DC306C","text":"1: 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示"},"1":{"objectClass":"MindNode","ID":"KI5W7","lineColorHex":"#DC306C","text":"2: GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸"},"2":{"objectClass":"MindNode","ID":"696T8","lineColorHex":"#DC306C","text":"3: 尽量减少视图数量和层次"},"3":{"objectClass":"MindNode","ID":"CB7ZO","lineColorHex":"#DC306C","text":"4: 减少透明的视图（alpha<1），不透明的就设置 opaque 为 YES"},"4":{"objectClass":"MindNode","ID":"U2X7Z","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"0H3UJ","lineColorHex":"#DC306C","text":"当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示屏幕缓冲区中进行。"},"objectClass":"NSArray"},"text":"5: 在屏渲染"},"5":{"objectClass":"MindNode","ID":"M7649","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"P81NV","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"K2V25","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"Z3731","lineColorHex":"#DC306C","text":"\t圆角（需要和maskToBounds一起使用）\n\t图层蒙版\n\t阴影\n\t光栅化"},"objectClass":"NSArray"},"text":"产生条件"},"objectClass":"NSArray"},"text":"指的是GPU的再当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作"},"objectClass":"NSArray"},"text":"6: 离屏渲染"},"6":{"objectClass":"MindNode","ID":"I7KXI","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"4X7YB","lineColorHex":"#DC306C","text":"1.预排版，提前计算\n2.预渲染，提前绘制\n3.异步绘制\n4.全局并发线程\n5.高效的图片异步加载"},"1":{"objectClass":"MindNode","ID":"SD443","lineColorHex":"#DC306C","text":"\t创建新的渲染缓冲区，会有内存上的开销。\n\t多通道渲染管线，最终需要合成，会涉及上下文切换，增加GPU的开销。\n\t总结：离屏渲染会增加GPU的处理时间，这样可能导致CPU + GPU的总处理时间超过16.7ms，从而出现掉帧卡顿的现象"},"objectClass":"NSArray"},"text":"7: 尽量避免出现离屏渲染"},"objectClass":"NSArray"},"text":"GPU：纹理的渲染，视图的混合，图形的生成\n"},"objectClass":"NSArray"},"text":"本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。"},"objectClass":"NSArray"},"text":"提升 tableview 的流畅度"},"objectClass":"NSArray"},"text":"UI卡顿优化"},"1":{"objectClass":"MindNode","ID":"H8W45","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"Z6IUV","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"2Z422","lineColorHex":"#BF58F5","text":"Analyze静态分析 （command ＋ shift ＋ b）\n主要分析以下四种问题：\n1、逻辑错误：访问空指针或未初始化的变量等；\n2、内存管理错误：如内存泄漏等；\n3、声明错误：从未使用过的变量；\n4、Api调用错误：未包含使用的库和框架。"},"objectClass":"NSArray"},"text":"静态分析"},"1":{"objectClass":"MindNode","ID":"YT558","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"SCRCV","lineColorHex":"#BF58F5","text":"product－>profile －>leaks 打开工具主窗口"},"objectClass":"NSArray"},"text":"动态分析"},"objectClass":"NSArray"},"text":"内存泄露问题"},"2":{"objectClass":"MindNode","ID":"EQ8S3","lineColorHex":"#26BBFF","children":{"0":{"objectClass":"MindNode","ID":"QGQ16","lineColorHex":"#26BBFF","text":"unrecognized selector crash\nKVO crash\nNSNotification crash\nNSTimer crash\nContainer crash（数组越界，插nil等）\nNSString crash （字符串操作的crash）\nBad Access crash （野指针）\nUI not on Main Thread Crash (非主线程刷UI (机制待改善))"},"objectClass":"NSArray"},"text":"crash防护"},"3":{"objectClass":"MindNode","ID":"17GU6","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"DNIS4","lineColorHex":"#37C45A","children":{"0":{"objectClass":"MindNode","ID":"DEQ53","lineColorHex":"#37C45A","text":"pre-main阶段优化：\n删除无用代码\n抽象重复代码\n+load方法做的事情延迟到initialize中，或者+load的事情不宜花费太多时间\n减少不必要的framework，或者优化已有framework\n移除废弃第三方库及所依赖的系统库，二进制重排（抖音优化方案）\n"},"1":{"objectClass":"MindNode","ID":"LB174","lineColorHex":"#37C45A","text":"Main阶段优化\ndidFinishLauchingwithOptions里代码延后执行\n首次启动渲染的页面优化"},"2":{"objectClass":"MindNode","ID":"O6VXJ","lineColorHex":"#37C45A","text":"runtime对类的注册，类对象的初始化，load方法加载阶段：精简类，合并分类，移除废弃分类等等"},"objectClass":"NSArray"},"text":"启动时间 = pre-main耗时+main耗时"},"objectClass":"NSArray"},"text":"App启动优化策略"},"4":{"objectClass":"MindNode","ID":"F5MT9","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"57B59","lineColorHex":"#1BD6E7","children":{"0":{"objectClass":"MindNode","ID":"X46SW","lineColorHex":"#1BD6E7","text":"Time Profiler: 性能分析\nZombies：僵尸对象检测（检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能）\nAllocations：（用来检查内存，写算法的那批人也用这个来检查）\nLeaks：内存泄露检测（以动态分析）。\n"},"objectClass":"NSArray"},"text":"Instruments工具的了解及使用情况"},"objectClass":"NSArray"},"text":"性能优化"},"5":{"objectClass":"MindNode","ID":"JO7K9","lineColorHex":"#FFC700","children":{"0":{"objectClass":"MindNode","ID":"GW9HU","lineColorHex":"#FFC700","text":"Profile-> Instruments ->Time Profiler"},"objectClass":"NSArray"},"text":"性能测试"},"6":{"objectClass":"MindNode","ID":"A9IKP","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"7DZI1","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"SO1C5","lineColorHex":"#DC306C","text":"1.慢查询监控\n2.多查询优化 \n3.常用接口cache：对于常用的接口进行缓存处理。\n 4.多接口合并：所谓的多接口合并也就是某个页面内请求过多，也可以考虑做一定的请求合并。"},"objectClass":"NSArray"},"text":"接口设计优化"},"1":{"objectClass":"MindNode","ID":"42287","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"43X23","lineColorHex":"#DC306C","text":"1.对数据进行 Gzip 压缩。\n 2.精简数据格式,如 JSON 代替 XML，WebP 代替其他图片格式。\n 3.针对不同设备不同网络返回不同数据格式。\n\n 如不同分辨率图片大小（可配合七牛）：\n 2/3G使用低清晰度图片——>下发300X240，精度为80的图片\n 4G普通清晰度图片——>下发600X480，精度为80的图片 \nWiFi高清晰度图片（最好根据网速来判断，wifi也有慢的）——>下发600X480，精度为100的图片。"},"objectClass":"NSArray"},"text":"数据压缩再处理"},"2":{"objectClass":"MindNode","ID":"EXW44","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"N7M55","lineColorHex":"#DC306C","text":"对首页及特定一级页面进行数据缓存\n在一定的有效时间内再次请求可以直接从缓存读取数据，也可避免空白页出现影响体验。"},"objectClass":"NSArray"},"text":"数据缓存"},"3":{"objectClass":"MindNode","ID":"R3GE4","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"VC896","lineColorHex":"#DC306C","text":"1.针对弱网(移动网络), 不自动加载图片（显示本占位图）。 \n2.界面先反馈, 请求延迟提交。例如, 用户点赞操作, 可以直接给出界面的点赞成功的反馈,在网络情况较好的时候再发起请求.（类似支付宝没网也能扫码支付。）\n"},"objectClass":"NSArray"},"text":"界面优化"},"objectClass":"NSArray"},"text":"弱网状态下如何优化"},"objectClass":"NSArray"},"text":"性能优化"}}