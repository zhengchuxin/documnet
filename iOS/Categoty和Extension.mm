{"objectClass":"NSDictionary","root":{"objectClass":"MindNode","ID":"Y3ZN7","rootPoint":{"objectClass":"CGPoint","x":415,"y":2180},"lineColorHex":"#BBBBBB","children":{"0":{"objectClass":"MindNode","ID":"VCIW0","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"015X8","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"9AXNH","lineColorHex":"#DC306C","text":"1: Runtime初始化时categroy的内存布局已经确定，没有ivar，所以默认不能添加属性。（分类的底层实现，category成员变量列表是只读）\n2: 使用runtime的关联对象，并重写setter和getter方法。"},"1":{"objectClass":"MindNode","ID":"33GU5","lineColorHex":"#DC306C","text":"1: category方法会在runtime初始化的时候copy到原来前面，调用分类方法的时候直接返回，不再调用原类\n2: 多个category的调用顺序按照：Build Phases ->Complie Source 中的编译顺序"},"2":{"objectClass":"MindNode","ID":"0H54Y","lineColorHex":"#DC306C","text":"3 : category成员变量列表是只读，所以category不能添加实例变量"},"3":{"objectClass":"MindNode","ID":"2L482","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"82184","lineColorHex":"#DC306C","text":"思路1 : 给分类添加全局变量，并且手动重写setter/getter方法实现。但是全局变量有很多隐患，对象销毁时无法销毁。不建议采用"},"1":{"objectClass":"MindNode","ID":"3V68G","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"488C6","lineColorHex":"#DC306C","text":"添加关联对象\nvoid objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy\n"},"1":{"objectClass":"MindNode","ID":"Q3H3H","lineColorHex":"#DC306C","text":"获得关联对象\nid objc_getAssociatedObject(id object, const void * key)"},"2":{"objectClass":"MindNode","ID":"P54L4","lineColorHex":"#DC306C","text":"移除所有的关联对象\nvoid objc_removeAssociatedObjects(id object)\n"},"objectClass":"NSArray"},"text":"思路2 : 用关联对象方法添加实例变量。 通过runtime提供的关联对象的方法可以简洁的给分类添加成员变量。 通过下面提供的关联对象下API，可以实现给分类添加实例变量:"},"objectClass":"NSArray"},"text":"4: 间接的添加"},"4":{"objectClass":"MindNode","ID":"3268Y","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"X9Q8W","lineColorHex":"#DC306C","text":"1: 关联对象并没有添加到实例变量到被关联对象内存中"},"1":{"objectClass":"MindNode","ID":"I7W5R","lineColorHex":"#DC306C","text":"2: 关联对象有一个全局内容管理器（「AssociationsManager」）并且为不同的分类添加的关联对象的值全都放在同一个全局容器中"},"2":{"objectClass":"MindNode","ID":"9261M","lineColorHex":"#DC306C","text":"3: 通过上面提到的三个API，操作实例变量 存取，移除。从而完成了对分类的添加实例变量"},"objectClass":"NSArray"},"text":"5: 关联对象方法添加实例变量原理"},"objectClass":"NSArray"},"text":"不能添加属性？怎么实现添加？"},"1":{"objectClass":"MindNode","ID":"JB8Z6","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"HC0R8","lineColorHex":"#DC306C","text":"1 ：给现有类添加方法，丰富现有类的功能。 比如有的人就为NSString这类添加了一些很实用的方法（判断字符串是否邮箱，转化字符串为MD5）"},"1":{"objectClass":"MindNode","ID":"TT8M8","lineColorHex":"#DC306C","text":"2: 分解代码庞大功能复杂的类。把功能复杂代码很多的类，可以按照不同功能的做分类，同一功能放到一个文件里，体现单一职责原则。"},"2":{"objectClass":"MindNode","ID":"38581","lineColorHex":"#DC306C","text":"3 ：声明私有方法。比如定义一个分类，只有头文件放到对应宿主.m里，满足私有方法的声明和使用，不暴露具体实现。"},"3":{"objectClass":"MindNode","ID":"068FV","lineColorHex":"#DC306C","text":"4: 把Framework的私有方法公开"},"objectClass":"NSArray"},"text":"使用场景"},"2":{"objectClass":"MindNode","ID":"B5277","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"7MOU3","lineColorHex":"#DC306C","text":"1: 其实覆盖没有真正的覆盖。如果在category里添加了methodA，那么原类的methodA也是存在的，没有真正覆盖掉。只是系统只会调用后来category添加的 methodA。"},"1":{"objectClass":"MindNode","ID":"7494U","lineColorHex":"#DC306C","text":"2: 因为category的methodA被放到了方法列表的前面，原来类中methodA被放到了方法列表的后面，在运行时查找方法会先找到了category 添加的同名方法，就产生了“覆盖“原来类的同名方法的效果。\n"},"2":{"objectClass":"MindNode","ID":"20T71","lineColorHex":"#DC306C","text":"3: 如果多个分类有同名方法，那么谁能生效取决于谁最后参与编译。最后参与编译的分类对应的方法就会生效。"},"objectClass":"NSArray"},"text":"category方法覆盖的问题"},"3":{"objectClass":"MindNode","ID":"54YJ7","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"WC45G","lineColorHex":"#DC306C","text":"1: 分类是运行时决议"},"1":{"objectClass":"MindNode","ID":"4NUV2","lineColorHex":"#DC306C","text":"2: 编译好的分类的文件，是没把相应分类的内容加到宿主类上的。只有在运行时Runtime 才把分类的内容添加到宿主类上。"},"2":{"objectClass":"MindNode","ID":"17B2L","lineColorHex":"#DC306C","text":"3: 可以为系统类添加分类"},"3":{"objectClass":"MindNode","ID":"1R4P3","lineColorHex":"#DC306C","text":"4: 比如会经常使用分类为UI控件封装一些常用方法"},"objectClass":"NSArray"},"text":"什么特点"},"4":{"objectClass":"MindNode","ID":"9Q05O","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"3I06Y","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"5YYO4","lineColorHex":"#DC306C","text":"1：类的名字（name）\n类（cls）\ncategory中所有给类添加的实例方法的列表（instanceMethods）\ncategory中所有添加的类方法的列表（classMethods）\ncategory实现的所有协议的列表（protocols）\ncategory中添加的所有属性instanceProperties）\ntypedef struct category_t {\n       const char *name; // 分类的名称\n       classref_t cls;  // 分类的宿主类\n       struct method_list_t *instanceMethods;  // 实例方法列表\n       struct method_list_t *classMethods; // 实例属性列表\n       struct protocol_list_t *protocols;\n       struct property_list_t *instanceProperties;\n      } category_t;"},"1":{"objectClass":"MindNode","ID":"2XOP8","lineColorHex":"#DC306C","text":"2: 从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性；在分类中定义属性，实际上只声明了setter方法和getter方法，并没有生成对应的实例变量。可以通过runtime的关联对象机制添加实例变量）。 category成员变量列表是只读，所以category不能添加实例变量"},"2":{"objectClass":"MindNode","ID":"FJPC0","lineColorHex":"#DC306C","text":"3: 声明的属性，只会生成getter和setter方法的声明，不会自动生成实例变量及getter和setter方法的实现"},"objectClass":"NSArray"},"text":"1: 在runtime层都是类和对象都是 struct表示的，category也不例外，category用结构体category_t"},"objectClass":"NSArray"},"text":"底层实现是什么"},"5":{"objectClass":"MindNode","ID":"TFR6G","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"D2522","lineColorHex":"#DC306C","text":"1: 取决于分类的编译顺序。\n最后编译的分类当中的同名方法才会最终生效，前面的会被覆盖掉。"},"objectClass":"NSArray"},"text":"一个类添加分类A和分类B，两个分类中分别添加了名字相同的实例方法，那么哪个分类的方法最终会生效？"},"6":{"objectClass":"MindNode","ID":"CMQ6C","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"26L0X","lineColorHex":"#DC306C","text":"1: 分类添加的方法可以\"覆盖\"宿主类的同名方法"},"1":{"objectClass":"MindNode","ID":"AA7P3","lineColorHex":"#DC306C","text":"2: 同名分类方法谁能生效取决于编译顺序"},"2":{"objectClass":"MindNode","ID":"1XN0I","lineColorHex":"#DC306C","text":"3: 名字相同的分类会引起编译报错"},"objectClass":"NSArray"},"text":"分类的总结"},"7":{"objectClass":"MindNode","ID":"F48L4","lineColorHex":"#DC306C","children":{"0":{"objectClass":"MindNode","ID":"1633A","lineColorHex":"#DC306C","text":"1: 分类不能自动生成实例变量，需要通过关联对象技术来实现。"},"1":{"objectClass":"MindNode","ID":"38KB3","lineColorHex":"#DC306C","text":"2: 多个分类中有同名的方法的时候，只会执行最后编译的方法。\n"},"2":{"objectClass":"MindNode","ID":"956EA","lineColorHex":"#DC306C","text":"3: 当分类中有和宿主类同名的方法的时候，会\"覆盖\"宿主类方法而执行分类中同名方法。"},"objectClass":"NSArray"},"text":"局限性"},"objectClass":"NSArray"},"text":"Categroy"},"1":{"objectClass":"MindNode","ID":"T517H","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"GX5N9","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"6TRQ8","lineColorHex":"#BF58F5","text":"1 ： 把不想对外公开一些类的方法，属性，成员变量的时候可以用类的扩展 类扩展代码格式"},"1":{"objectClass":"MindNode","ID":"MX55T","lineColorHex":"#BF58F5","text":"2 ：@interface XXX ()\n//私有属性\n//私有方法（如果不实现，编译时会报警,Method definition for 'XXX' not found）\n@end"},"objectClass":"NSArray"},"text":"用途是什么"},"1":{"objectClass":"MindNode","ID":"L621N","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"P50X4","lineColorHex":"#BF58F5","text":"1: Extenstion编译期创建，可以添加成员变量ivar，一般用作隐藏类的信息。\n2: 必须要有类的源码才可以添加，如NSString就不能创建Extension。"},"objectClass":"NSArray"},"text":"创建时间"},"2":{"objectClass":"MindNode","ID":"I28CU","lineColorHex":"#BF58F5","children":{"0":{"objectClass":"MindNode","ID":"L70R1","lineColorHex":"#BF58F5","text":"1: 系统类可以添加分类，但是不能为系统类添加扩展。"},"1":{"objectClass":"MindNode","ID":"NJ7FO","lineColorHex":"#BF58F5","text":"2: 编译时决议"},"2":{"objectClass":"MindNode","ID":"343JV","lineColorHex":"#BF58F5","text":"3: 只以声明的形式存在(没有具体实现)，多数情况下寄生于宿主类的.m文件中\n"},"3":{"objectClass":"MindNode","ID":"OOIH0","lineColorHex":"#BF58F5","text":"4: 声明的属性，只会生成getter和setter方法的声明，会自动生成实例变量及getter和setter方法的实现"},"objectClass":"NSArray"},"text":"特点"},"objectClass":"NSArray"},"text":"Extenstion"},"objectClass":"NSArray"},"text":"Categroy和Extension"}}